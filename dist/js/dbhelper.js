const Database_Url="http://localhost:1337/",restById_Url="http://localhost:1337/restaurants/<restaurant_id>",favor_Url="http://localhost:1337/restaurants/?is_favorite=true",revs_Url="http://localhost:1337/reviews/",restRev_ById="http://localhost:1337/reviews/<review_id>",revById_Url="http://localhost:1337/reviews/?restaurant_id=",dbPromise=idb.open("restaDB",23,e=>{switch(e.oldVersion){case 0:e.createObjectStore("restaurants",{keyPath:"id"});case 1:e.createObjectStore("reviews",{keyPath:"id",autoIncrement:!0}).createIndex("restaurant","restaurant_id")}});class DBHelper{static get DATABASE_URL(){return Database_Url}static fetchRestaurants(e){fetch(DBHelper.DATABASE_URL+"restaurants").then(t=>t.json().then(t=>{dbPromise.then(r=>{const s=r.transaction("restaurants","readwrite"),a=s.objectStore("restaurants");return t.forEach(e=>(a.put(e),s.complete)),e(null,t),console.log(a.getAll()),a.getAll()}).catch(r=>{e(r,t),console.log(r)})}))}static fetchRestaurantById(e,t){DBHelper.fetchRestaurants((r,s)=>{if(r)t(r,null);else{const r=s.find(t=>t.id==e);console.log(r),r?t(null,r):t("Restaurant does not exist",null)}}),fetch(revById_Url+e).then(t=>t.json().then(t=>{console.log("fetched the reviews from the url:",t),console.log("and this was the url id:",e),dbPromise.then(e=>{const r=e.transaction("reviews","readwrite"),s=r.objectStore("reviews");Array.isArray(t)&&t.map(e=>(s.put(e),r.complete))})}).catch(e=>{console.log(e)}))}static fetchRestaurantByCuisine(e,t){DBHelper.fetchRestaurants((r,s)=>{if(r)t(r,null);else{const r=s.filter(t=>t.cuisine_type==e);t(null,r)}})}static fetchRestaurantByNeighborhood(e,t){DBHelper.fetchRestaurants((r,s)=>{if(r)t(r,null);else{const r=s.filter(t=>t.neighborhood==e);t(null,r)}})}static fetchRestaurantByCuisineAndNeighborhood(e,t,r){DBHelper.fetchRestaurants((s,a)=>{if(s)r(s,null);else{let s=a;"all"!=e&&(s=s.filter(t=>t.cuisine_type==e)),"all"!=t&&(s=s.filter(e=>e.neighborhood==t)),r(null,s)}})}static fetchNeighborhoods(e){DBHelper.fetchRestaurants((t,r)=>{if(t)e(t,null);else{const t=r.map((e,t)=>r[t].neighborhood),s=t.filter((e,r)=>t.indexOf(e)==r);e(null,s)}})}static fetchCuisines(e){DBHelper.fetchRestaurants((t,r)=>{if(t)e(t,null);else{const t=r.map((e,t)=>r[t].cuisine_type),s=t.filter((e,r)=>t.indexOf(e)==r);e(null,s)}})}static urlForRestaurant(e){return`./restaurant.html?id=${e.id}`}static imageUrlForRestaurant(e){return e.photograph?`/img/${e.photograph}`:`/img/${e.id}`}static mapMarkerForRestaurant(e,t){const r=new L.marker([e.latlng.lat,e.latlng.lng],{title:e.name,alt:e.name,url:DBHelper.urlForRestaurant(e)});return r.addTo(newMap),r}static fetchReviewsById(e){return console.log("this is the fetch reviews function:",e),dbPromise.then(t=>{const r=t.transaction("reviews","readwrite").objectStore("reviews").index("restaurant");return e?(console.log("what is returned to fillReviewsHTML:",r.getAll(e)),r.getAll(e)):void 0})}static addNewReview(e){console.log("this is what is returned to the addReview:",e);const t=self.restaurant.id;fetch(revById_Url+t,{method:"POST",headers:new Headers({"Content-Type":"application/json;"}),body:JSON.stringify(e)}).then(()=>{dbPromise.then(t=>{const r=t.transaction("reviews","readwrite");return r.objectStore("reviews").put(e),r.complete})})}static updFavStatus(e,t){console.log("changed the status",t),fetch("http://localhost:1337/restaurants/"+e+"?is_favorite="+t,{method:"PUT"}).then(()=>{console.log("restaurant: "+e+" is_favorite was changed to "+t),dbPromise.then(r=>{const s=r.transaction("restaurants","readwrite").objectStore("restaurants");s.get(e).then(e=>{t=e.is_favorite,s.put(e)})})})}}